name: Foundation Domain CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'ai-services/**'
      - 'shared-infrastructure/**'
      - 'centralized-dashboard/**'
      - 'central-configuration/**'
      - 'shared-libraries/**'
  pull_request:
    branches: [ main, develop ]

env:
  REGISTRY: ghcr.io
  JAVA_VERSION: '21'
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'

jobs:
  # Detect changes to optimize build time
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      java-services: ${{ steps.changes.outputs.java-services }}
      nodejs-services: ${{ steps.changes.outputs.nodejs-services }}
      python-services: ${{ steps.changes.outputs.python-services }}
      shared-libs: ${{ steps.changes.outputs.shared-libs }}
    steps:
      - uses: actions/checkout@v4

      - name: Detect changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            java-services:
              - '**/pom.xml'
              - '**/src/main/java/**'
            nodejs-services:
              - '**/package.json'
              - '**/src/**/*.js'
            python-services:
              - '**/requirements.txt'
              - '**/src/**/*.py'
            shared-libs:
              - 'shared-libraries/**'

  # Build and test Java services
  build-java:
    needs: detect-changes
    if: needs.detect-changes.outputs.java-services == 'true' || needs.detect-changes.outputs.shared-libs == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        domain: [ai-services, shared-infrastructure, centralized-dashboard, central-configuration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v3
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Build shared libraries first
        if: matrix.domain != 'shared-libraries'
        run: |
          cd shared-libraries
          mvn clean install -DskipTests

      - name: Build Java services
        run: |
          cd ${{ matrix.domain }}/backend-services/java-services
          find . -name "pom.xml" -type f | xargs -I {} dirname {} | sort | while read service; do
            echo "Building $service"
            cd "$service"
            mvn clean package -DskipTests
            cd - > /dev/null
          done

      - name: Run tests
        run: |
          cd ${{ matrix.domain }}/backend-services/java-services
          find . -name "pom.xml" -type f | xargs -I {} dirname {} | sort | while read service; do
            if [ -f "$service/pom.xml" ]; then
              echo "Testing $service"
              cd "$service"
              mvn test
              cd - > /dev/null
            fi
          done

      - name: Build Docker images
        run: |
          cd ${{ matrix.domain }}/backend-services/java-services
          find . -name "Dockerfile" -type f | xargs -I {} dirname {} | sort | while read service; do
            echo "Building Docker image for $service"
            cd "$service"
            service_name=$(basename "$service")
            docker build -t ${{ env.REGISTRY }}/${{ github.repository }}-${{ matrix.domain }}-$service_name:${{ github.sha }} .
            cd - > /dev/null
          done

  # Build and test Node.js services
  build-nodejs:
    needs: detect-changes
    if: needs.detect-changes.outputs.nodejs-services == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        domain: [ai-services, shared-infrastructure, centralized-dashboard]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install and build Node.js services
        run: |
          cd ${{ matrix.domain }}/backend-services/nodejs-services
          find . -name "package.json" -type f | xargs -I {} dirname {} | sort | while read service; do
            if [ -f "$service/package.json" ]; then
              echo "Building $service"
              cd "$service"
              npm ci
              npm run build 2>/dev/null || echo "No build script found"
              npm test 2>/dev/null || echo "No tests found"
              cd - > /dev/null
            fi
          done

      - name: Build Docker images
        run: |
          cd ${{ matrix.domain }}/backend-services/nodejs-services
          find . -name "Dockerfile" -type f | xargs -I {} dirname {} | sort | while read service; do
            if [ -f "$service/Dockerfile" ]; then
              echo "Building Docker image for $service"
              cd "$service"
              service_name=$(basename "$service")
              docker build -t ${{ env.REGISTRY }}/${{ github.repository }}-${{ matrix.domain }}-$service_name:${{ github.sha }} .
              cd - > /dev/null
            fi
          done

  # Build and test Python services
  build-python:
    needs: detect-changes
    if: needs.detect-changes.outputs.python-services == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        domain: [ai-services]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install and build Python services
        run: |
          cd ${{ matrix.domain }}/backend-services/python-services
          find . -name "requirements.txt" -type f | xargs -I {} dirname {} | sort | while read service; do
            if [ -f "$service/requirements.txt" ]; then
              echo "Building $service"
              cd "$service"
              pip install -r requirements.txt
              python -m pytest . 2>/dev/null || echo "No pytest tests found"
              cd - > /dev/null
            fi
          done

      - name: Build Docker images
        run: |
          cd ${{ matrix.domain }}/backend-services/python-services
          find . -name "Dockerfile" -type f | xargs -I {} dirname {} | sort | while read service; do
            if [ -f "$service/Dockerfile" ]; then
              echo "Building Docker image for $service"
              cd "$service"
              service_name=$(basename "$service")
              docker build -t ${{ env.REGISTRY }}/${{ github.repository }}-${{ matrix.domain }}-$service_name:${{ github.sha }} .
              cd - > /dev/null
            fi
          done

  # Security scanning
  security-scan:
    needs: [build-java, build-nodejs, build-python]
    runs-on: ubuntu-latest
    if: always() && (needs.build-java.result != 'skipped' || needs.build-nodejs.result != 'skipped' || needs.build-python.result != 'skipped')
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ github.repository }}-ai-services-*:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Deploy to staging (only on develop branch)
  deploy-staging:
    needs: [build-java, build-nodejs, build-python, security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy Java services with Helm
        run: |
          export KUBECONFIG=kubeconfig
          for domain in ai-services shared-infrastructure centralized-dashboard central-configuration; do
            cd "$domain/backend-services/java-services"
            find . -name "Chart.yaml" -type f | xargs -I {} dirname {} | sort | while read service; do
              if [ -f "$service/Chart.yaml" ]; then
                echo "Deploying $service"
                service_name=$(basename "$service")
                helm upgrade --install $service_name $service \
                  --namespace foundation-staging \
                  --set image.tag=${{ github.sha }} \
                  --set image.repository=${{ env.REGISTRY }}/${{ github.repository }}-$domain-$service_name \
                  --wait --timeout=10m
              fi
            done
            cd - > /dev/null
          done

      - name: Deploy Node.js and Python services
        run: |
          export KUBECONFIG=kubeconfig
          for domain in ai-services shared-infrastructure centralized-dashboard; do
            # Deploy Node.js services
            if [ -d "$domain/backend-services/nodejs-services" ]; then
              cd "$domain/backend-services/nodejs-services"
              find . -name "kubernetes" -type d | while read kube_dir; do
                echo "Deploying from $kube_dir"
                kubectl apply -f "$kube_dir" -n foundation-staging
              done
              cd - > /dev/null
            fi

            # Deploy Python services
            if [ -d "$domain/backend-services/python-services" ]; then
              cd "$domain/backend-services/python-services"
              find . -name "kubernetes" -type d | while read kube_dir; do
                echo "Deploying from $kube_dir"
                kubectl apply -f "$kube_dir" -n foundation-staging
              done
              cd - > /dev/null
            fi
          done

  # Smoke tests
  smoke-tests:
    needs: deploy-staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    steps:
      - name: Run smoke tests
        run: |
          # Add smoke test commands here
          echo "Running smoke tests on staging environment"
          # Example: curl health endpoints

      - name: Notify Slack on success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          text: '✅ Foundation Domain deployed to staging successfully!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          text: '❌ Foundation Domain deployment to staging failed!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}